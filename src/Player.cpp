#include "Player.h"
#include <stdexcept>
#include <iostream>

// assets_symbols.h is generated at build time by embed_assets.py and placed into build/generated
#include "assets_symbols.h"

static sf::Texture loadTex(const unsigned char* s, const unsigned char* e)
{
    sf::Texture t;
    if (!t.loadFromMemory(s, static_cast<std::size_t>(e - s)))
        throw std::runtime_error("Player::loadTex failed");
    return t;
}

Player::Player()
    : dummyTexture()
    , sprite(dummyTexture)
{
    loadAssets();
    setStand();
}

void Player::loadAssets()
{
    standFrames.clear();
    standFrames.reserve(5);

    // use ASSET_START_<sym> / ASSET_END_<sym> macros generated by script
    standFrames.push_back(loadTex(ASSET_START_player_player0001, ASSET_END_player_player0001));
    standFrames.push_back(loadTex(ASSET_START_player_player0002, ASSET_END_player_player0002));
    standFrames.push_back(loadTex(ASSET_START_player_player0003, ASSET_END_player_player0003));
    standFrames.push_back(loadTex(ASSET_START_player_player0004, ASSET_END_player_player0004));
    standFrames.push_back(loadTex(ASSET_START_player_player0005, ASSET_END_player_player0005));

    attackFrames.clear();
    attackFrames.reserve(24);
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0001, ASSET_END_attack_attack0001));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0002, ASSET_END_attack_attack0002));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0003, ASSET_END_attack_attack0003));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0004, ASSET_END_attack_attack0004));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0005, ASSET_END_attack_attack0005));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0006, ASSET_END_attack_attack0006));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0007, ASSET_END_attack_attack0007));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0008, ASSET_END_attack_attack0008));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0009, ASSET_END_attack_attack0009));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0010, ASSET_END_attack_attack0010));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0011, ASSET_END_attack_attack0011));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0012, ASSET_END_attack_attack0012));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0013, ASSET_END_attack_attack0013));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0014, ASSET_END_attack_attack0014));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0015, ASSET_END_attack_attack0015));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0016, ASSET_END_attack_attack0016));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0017, ASSET_END_attack_attack0017));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0018, ASSET_END_attack_attack0018));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0019, ASSET_END_attack_attack0019));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0020, ASSET_END_attack_attack0020));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0021, ASSET_END_attack_attack0021));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0022, ASSET_END_attack_attack0022));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0023, ASSET_END_attack_attack0023));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0024, ASSET_END_attack_attack0024));
}

void Player::setStand()
{
    currentFrames = &standFrames;
    currentFrame = 0;
    timer = 0.f;
    if (!currentFrames->empty())
        sprite.setTexture((*currentFrames)[0], true);
}

void Player::setAttack()
{
    currentFrames = &attackFrames;
    currentFrame = 0;
    timer = 0.f;
    if (!currentFrames->empty())
        sprite.setTexture((*currentFrames)[0], true);
}

bool Player::isAttackFinished() const
{
    return currentFrames == &attackFrames &&
           currentFrame >= static_cast<int>(attackFrames.size() - 1);
}

void Player::update(float dt)
{
    if (!currentFrames || currentFrames->empty()) return;

    timer += dt;
    if (timer < frameDuration) return;
    timer = 0.f;

    currentFrame++;
    if (currentFrame >= static_cast<int>(currentFrames->size()))
    {
        currentFrame = static_cast<int>(currentFrames->size()) - 1;
    }

    sprite.setTexture((*currentFrames)[currentFrame], true);
}

void Player::draw(sf::RenderWindow& window)
{
    window.draw(sprite);
}