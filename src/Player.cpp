#include "Player.h"
#include <stdexcept>
#include <iostream>

// assets_symbols.h is generated at build time by embed_assets.py and placed into build/generated
#include "assets_symbols.h"

static sf::Texture loadTex(const unsigned char* s, const unsigned char* e)
{
    sf::Texture t;
    if (!t.loadFromMemory(s, static_cast<std::size_t>(e - s)))
        throw std::runtime_error("Player::loadTex failed");
    return t;
}

Player::Player()
    : dummyTexture()
    , sprite(dummyTexture)
{
    loadAssets();
    setStand();

    // ğŸ”¥ åªè®¾ç½®ä¸€æ¬¡ originï¼ˆç»Ÿä¸€ä¸­å¿ƒï¼‰
    auto bounds = sprite.getLocalBounds();
    sprite.setOrigin(bounds.size / 2.f);
}

void Player::loadAssets()
{
    standFrames.clear();
    standFrames.reserve(5);

    // use ASSET_START_<sym> / ASSET_END_<sym> macros generated by script
    standFrames.push_back(loadTex(ASSET_START_player_player0001, ASSET_END_player_player0001));
    standFrames.push_back(loadTex(ASSET_START_player_player0002, ASSET_END_player_player0002));
    standFrames.push_back(loadTex(ASSET_START_player_player0003, ASSET_END_player_player0003));
    standFrames.push_back(loadTex(ASSET_START_player_player0004, ASSET_END_player_player0004));
    standFrames.push_back(loadTex(ASSET_START_player_player0005, ASSET_END_player_player0005));

    attackFrames.clear();
    attackFrames.reserve(24);
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0001, ASSET_END_attack_attack0001));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0002, ASSET_END_attack_attack0002));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0003, ASSET_END_attack_attack0003));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0004, ASSET_END_attack_attack0004));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0005, ASSET_END_attack_attack0005));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0006, ASSET_END_attack_attack0006));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0007, ASSET_END_attack_attack0007));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0008, ASSET_END_attack_attack0008));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0009, ASSET_END_attack_attack0009));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0010, ASSET_END_attack_attack0010));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0011, ASSET_END_attack_attack0011));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0012, ASSET_END_attack_attack0012));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0013, ASSET_END_attack_attack0013));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0014, ASSET_END_attack_attack0014));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0015, ASSET_END_attack_attack0015));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0016, ASSET_END_attack_attack0016));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0017, ASSET_END_attack_attack0017));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0018, ASSET_END_attack_attack0018));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0019, ASSET_END_attack_attack0019));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0020, ASSET_END_attack_attack0020));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0021, ASSET_END_attack_attack0021));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0022, ASSET_END_attack_attack0022));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0023, ASSET_END_attack_attack0023));
    attackFrames.push_back(loadTex(ASSET_START_attack_attack0024, ASSET_END_attack_attack0024));

    walkFrames.clear();
    walkFrames.reserve(11);
    walkFrames.push_back(loadTex(ASSET_START_walk_walk0001, ASSET_END_walk_walk0001));
    walkFrames.push_back(loadTex(ASSET_START_walk_walk0002, ASSET_END_walk_walk0002));
    walkFrames.push_back(loadTex(ASSET_START_walk_walk0003, ASSET_END_walk_walk0003));
    walkFrames.push_back(loadTex(ASSET_START_walk_walk0004, ASSET_END_walk_walk0004));
    walkFrames.push_back(loadTex(ASSET_START_walk_walk0005, ASSET_END_walk_walk0005));
    walkFrames.push_back(loadTex(ASSET_START_walk_walk0006, ASSET_END_walk_walk0006));
    walkFrames.push_back(loadTex(ASSET_START_walk_walk0007, ASSET_END_walk_walk0007));
    walkFrames.push_back(loadTex(ASSET_START_walk_walk0008, ASSET_END_walk_walk0008));
    walkFrames.push_back(loadTex(ASSET_START_walk_walk0009, ASSET_END_walk_walk0009));
    walkFrames.push_back(loadTex(ASSET_START_walk_walk0010, ASSET_END_walk_walk0010));
    walkFrames.push_back(loadTex(ASSET_START_walk_walk0011, ASSET_END_walk_walk0011));
}

void Player::applyFrame()
{
    sprite.setTexture((*currentFrames)[currentFrame], true);

    // ä¿æŒç¿»è½¬
    sprite.setScale(direction == -1 ?
        sf::Vector2f{-1.f, 1.f} :
        sf::Vector2f{1.f, 1.f});
}

void Player::setStand()
{
    currentFrames = &standFrames;
    currentFrame = 0;
    timer = 0.f;
    applyFrame();
}

void Player::setAttack()
{
    currentFrames = &attackFrames;
    currentFrame = 0;
    timer = 0.f;
    applyFrame();
}

void Player::setWalk()
{
    currentFrames = &walkFrames;
    currentFrame = 0;
    timer = 0.f;
    applyFrame();
}

bool Player::isAttackFinished() const
{
    return currentFrames == &attackFrames &&
           currentFrame >= static_cast<int>(attackFrames.size() - 1);
}

void Player::update(float dt)
{
    if (!currentFrames || currentFrames->empty()) return;

    timer += dt;
    if (timer < frameDuration) return;
    timer = 0.f;

    currentFrame++;

    if (currentFrames == &attackFrames)
    {
        if (currentFrame >= static_cast<int>(currentFrames->size()))
            currentFrame = static_cast<int>(currentFrames->size()) - 1;
    }
    else
    {
        if (currentFrame >= static_cast<int>(currentFrames->size()))
            currentFrame = 0;
    }

    applyFrame();
}

void Player::draw(sf::RenderWindow& window)
{
    window.draw(sprite);
}

void Player::move(float dx)
{
    sprite.move({dx, 0.f});
}

void Player::setDirection(int dir)
{
    direction = dir;
    sprite.setScale(direction == -1 ?
        sf::Vector2f{-1.f, 1.f} :
        sf::Vector2f{1.f, 1.f});
}

void Player::setPosition(const sf::Vector2f& pos)
{
    sprite.setPosition(pos);
}